// Rough work
branch and bound:
add the basic node to the priority queue
while priority queue isn't empty
    pop, and check the upper bound versus current best solution, if it is less, then the current best solution is the best solution to be found
    else
        check if the temp is a last ancestor, and if it is, update the max value
    else
        make two new nodes and add them to the priority queue

new function to compute the upper bound???
    needs the length ie the current item being looked at to figure out which items have already been seen. it also needs the parents value and it's own value
    if it's being picked up.

    Then it can go through the sorted identifiers trying to find one that is greater than the length. When it finds it,
    it tries to pick up the item. if it can be picked up increase ub decrease capapcity and move to the next items.
    if it can't be picked up go to the end of the list of identifiers sorted in increasing order whilst increasing upper bound and decreasing the cpapcity.



// rough code
while (!pq.isEmpty()) {
            temp = pq.poll();
            System.out.printf("Node string %s, ub %d value %d\n", temp.solution, temp.ub, temp.value);
            // create new nodes and enqueue them
            temp1 = null;
            temp2 = null;
            // check if temp is last parent
            if (temp.solution.length() == n - 1) {

                if (temp.remainingCap >= weights[temp.solution.length()]) {
                    // pick up last item
                    int lastVal = values[temp.solution.length()];
                    int lastWeight = weights[temp.solution.length()];
                    temp1 = new Node(temp.solution + "1", temp.ub + lastVal, temp.value + lastVal,
                            temp.remainingCap - lastWeight);
                    // todo, prune priority queue
                }
                temp2 = new Node(temp.solution + "0", temp.value, temp.value, temp.remainingCap);
                // todo, prune priority queue
            } else {
                // temp is not last parent
                int ubtemp1, ubtemp2;
                // for upper bound go through the leftover items
                for (int i = temp.solution.length(); i < n; i++) {

                }
            }

            // Node temp1 = new Node(temp.solution+"1", ub,
            // temp.value+values[temp.solution.length()]);
            // Node temp2 = new Node(temp.solution+"0", ub, temp.value);
        }